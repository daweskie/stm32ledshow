   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"led_blinking.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.waPort_D0_Blinker,"aw",%nobits
  20              		.align	3
  23              	waPort_D0_Blinker:
  24 0000 00000000 		.space	440
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              		.section	.rodata
  26              		.align	2
  27              	.LC0:
  28 0000 506F7274 		.ascii	"Port_D0_Blinker\000"
  28      5F44305F 
  28      426C696E 
  28      6B657200 
  29              		.section	.text.Port_D0_Blinker,"ax",%progbits
  30              		.align	2
  31              		.p2align 4,,15
  32              		.thumb
  33              		.thumb_func
  35              	Port_D0_Blinker:
  36              	.LFB118:
  37              		.file 1 "led_blinking.c"
   1:led_blinking.c **** 
   2:led_blinking.c **** #include <stdlib.h>
   3:led_blinking.c **** #include <string.h>
   4:led_blinking.c **** 
   5:led_blinking.c **** #include "ch.h"
   6:led_blinking.c **** #include "hal.h"
   7:led_blinking.c **** 
   8:led_blinking.c **** #include "chprintf.h"
   9:led_blinking.c **** 
  10:led_blinking.c **** #include "led_blinking.h"
  11:led_blinking.c **** 
  12:led_blinking.c **** /*
  13:led_blinking.c ****  * This module handles processes to perform random LED blinking for LEDs
  14:led_blinking.c ****  * connected to port pins connected to external transistors.
  15:led_blinking.c ****  */
  16:led_blinking.c **** 
  17:led_blinking.c **** 
  18:led_blinking.c **** /*
  19:led_blinking.c ****  * Port D blinker thread, times are in milliseconds.
  20:led_blinking.c ****  *  Blink the LEDs on port D
  21:led_blinking.c ****  *
  22:led_blinking.c ****  *  This is not the clearest or the quickest way to do this, but it is by
  23:led_blinking.c ****  *      far the most clear way to do it.
  24:led_blinking.c ****  *  We get a random number and assign it to a 16-bit variable.  We then
  25:led_blinking.c ****  *    check each bit and map it to an port pin that has a transistor
  26:led_blinking.c ****  *    driven LED connected to it.
  27:led_blinking.c ****  */
  28:led_blinking.c **** static WORKING_AREA(waPort_D0_Blinker, 128);
  29:led_blinking.c **** static msg_t Port_D0_Blinker(void *arg)
  30:led_blinking.c **** {
  38              		.loc 1 30 0
  39              		.cfi_startproc
  40              		@ args = 0, pretend = 0, frame = 16
  41              		@ frame_needed = 0, uses_anonymous_args = 0
  42 0000 00B5     		push	{lr}
  43              		.cfi_def_cfa_offset 4
  44              		.cfi_offset 14, -4
  45 0002 85B0     		sub	sp, sp, #20
  46              		.cfi_def_cfa_offset 24
  47 0004 0190     		str	r0, [sp, #4]
  31:led_blinking.c ****     uint32_t pattern;
  32:led_blinking.c ****     (void)arg;
  33:led_blinking.c **** 
  34:led_blinking.c ****     chRegSetThreadName("Port_D0_Blinker");
  48              		.loc 1 34 0
  49 0006 2B4B     		ldr	r3, .L15
  50 0008 9B69     		ldr	r3, [r3, #24]
  51 000a 2B4A     		ldr	r2, .L15+4
  52 000c 9A61     		str	r2, [r3, #24]
  35:led_blinking.c **** 
  36:led_blinking.c ****     srand( 93475 );
  53              		.loc 1 36 0
  54 000e 2B48     		ldr	r0, .L15+8
  55 0010 FFF7FEFF 		bl	srand
  56              	.L14:
  37:led_blinking.c **** 
  38:led_blinking.c ****     while (TRUE)
  39:led_blinking.c ****     {
  40:led_blinking.c ****       pattern = rand() ;
  57              		.loc 1 40 0
  58 0014 FFF7FEFF 		bl	rand
  59 0018 0346     		mov	r3, r0
  60 001a 0393     		str	r3, [sp, #12]
  41:led_blinking.c **** 
  42:led_blinking.c ****       if( pattern & 0b0000000000000001 )
  61              		.loc 1 42 0
  62 001c 039B     		ldr	r3, [sp, #12]
  63 001e 03F00103 		and	r3, r3, #1
  64 0022 002B     		cmp	r3, #0
  65 0024 03D0     		beq	.L2
  43:led_blinking.c ****       {
  44:led_blinking.c ****           palSetPad(GPIOD, GPIOD_PIN0);
  66              		.loc 1 44 0
  67 0026 264B     		ldr	r3, .L15+12
  68 0028 0122     		movs	r2, #1
  69 002a 1A83     		strh	r2, [r3, #24]	@ movhi
  70 002c 02E0     		b	.L3
  71              	.L2:
  45:led_blinking.c ****       }
  46:led_blinking.c ****       else
  47:led_blinking.c ****       {
  48:led_blinking.c ****         palClearPad(GPIOD, GPIOD_PIN0);
  72              		.loc 1 48 0
  73 002e 244B     		ldr	r3, .L15+12
  74 0030 0122     		movs	r2, #1
  75 0032 5A83     		strh	r2, [r3, #26]	@ movhi
  76              	.L3:
  49:led_blinking.c ****       }
  50:led_blinking.c **** 
  51:led_blinking.c ****       if( pattern & 0b0000000000000010 )
  77              		.loc 1 51 0
  78 0034 039B     		ldr	r3, [sp, #12]
  79 0036 03F00203 		and	r3, r3, #2
  80 003a 002B     		cmp	r3, #0
  81 003c 03D0     		beq	.L4
  52:led_blinking.c ****       {
  53:led_blinking.c ****           palSetPad(GPIOD, GPIOD_PIN1);
  82              		.loc 1 53 0
  83 003e 204B     		ldr	r3, .L15+12
  84 0040 0222     		movs	r2, #2
  85 0042 1A83     		strh	r2, [r3, #24]	@ movhi
  86 0044 02E0     		b	.L5
  87              	.L4:
  54:led_blinking.c ****       }
  55:led_blinking.c ****       else
  56:led_blinking.c ****       {
  57:led_blinking.c ****         palClearPad(GPIOD, GPIOD_PIN1);
  88              		.loc 1 57 0
  89 0046 1E4B     		ldr	r3, .L15+12
  90 0048 0222     		movs	r2, #2
  91 004a 5A83     		strh	r2, [r3, #26]	@ movhi
  92              	.L5:
  58:led_blinking.c ****       }
  59:led_blinking.c **** 
  60:led_blinking.c ****       if( pattern & 0b0000000000000100 )
  93              		.loc 1 60 0
  94 004c 039B     		ldr	r3, [sp, #12]
  95 004e 03F00403 		and	r3, r3, #4
  96 0052 002B     		cmp	r3, #0
  97 0054 03D0     		beq	.L6
  61:led_blinking.c ****       {
  62:led_blinking.c ****           palSetPad(GPIOD, GPIOD_PIN2);
  98              		.loc 1 62 0
  99 0056 1A4B     		ldr	r3, .L15+12
 100 0058 0422     		movs	r2, #4
 101 005a 1A83     		strh	r2, [r3, #24]	@ movhi
 102 005c 02E0     		b	.L7
 103              	.L6:
  63:led_blinking.c ****       }
  64:led_blinking.c ****       else
  65:led_blinking.c ****       {
  66:led_blinking.c ****         palClearPad(GPIOD, GPIOD_PIN2);
 104              		.loc 1 66 0
 105 005e 184B     		ldr	r3, .L15+12
 106 0060 0422     		movs	r2, #4
 107 0062 5A83     		strh	r2, [r3, #26]	@ movhi
 108              	.L7:
  67:led_blinking.c ****       }
  68:led_blinking.c **** 
  69:led_blinking.c ****       if( pattern & 0b0000000000001000 )
 109              		.loc 1 69 0
 110 0064 039B     		ldr	r3, [sp, #12]
 111 0066 03F00803 		and	r3, r3, #8
 112 006a 002B     		cmp	r3, #0
 113 006c 03D0     		beq	.L8
  70:led_blinking.c ****       {
  71:led_blinking.c ****           palSetPad(GPIOD, GPIOD_PIN3);
 114              		.loc 1 71 0
 115 006e 144B     		ldr	r3, .L15+12
 116 0070 0822     		movs	r2, #8
 117 0072 1A83     		strh	r2, [r3, #24]	@ movhi
 118 0074 02E0     		b	.L9
 119              	.L8:
  72:led_blinking.c ****       }
  73:led_blinking.c ****       else
  74:led_blinking.c ****       {
  75:led_blinking.c ****         palClearPad(GPIOD, GPIOD_PIN3);
 120              		.loc 1 75 0
 121 0076 124B     		ldr	r3, .L15+12
 122 0078 0822     		movs	r2, #8
 123 007a 5A83     		strh	r2, [r3, #26]	@ movhi
 124              	.L9:
  76:led_blinking.c ****       }
  77:led_blinking.c **** 
  78:led_blinking.c **** 
  79:led_blinking.c ****       if( pattern & 0b0000000001000000 )
 125              		.loc 1 79 0
 126 007c 039B     		ldr	r3, [sp, #12]
 127 007e 03F04003 		and	r3, r3, #64
 128 0082 002B     		cmp	r3, #0
 129 0084 03D0     		beq	.L10
  80:led_blinking.c ****       {
  81:led_blinking.c ****           palSetPad(GPIOD, GPIOD_PIN6);
 130              		.loc 1 81 0
 131 0086 0E4B     		ldr	r3, .L15+12
 132 0088 4022     		movs	r2, #64
 133 008a 1A83     		strh	r2, [r3, #24]	@ movhi
 134 008c 02E0     		b	.L11
 135              	.L10:
  82:led_blinking.c ****       }
  83:led_blinking.c ****       else
  84:led_blinking.c ****       {
  85:led_blinking.c ****         palClearPad(GPIOD, GPIOD_PIN6);
 136              		.loc 1 85 0
 137 008e 0C4B     		ldr	r3, .L15+12
 138 0090 4022     		movs	r2, #64
 139 0092 5A83     		strh	r2, [r3, #26]	@ movhi
 140              	.L11:
  86:led_blinking.c ****       }
  87:led_blinking.c **** 
  88:led_blinking.c ****       if( pattern & 0b0000000010000000 )
 141              		.loc 1 88 0
 142 0094 039B     		ldr	r3, [sp, #12]
 143 0096 03F08003 		and	r3, r3, #128
 144 009a 002B     		cmp	r3, #0
 145 009c 03D0     		beq	.L12
  89:led_blinking.c ****       {
  90:led_blinking.c ****           palSetPad(GPIOD, GPIOD_PIN7);
 146              		.loc 1 90 0
 147 009e 084B     		ldr	r3, .L15+12
 148 00a0 8022     		movs	r2, #128
 149 00a2 1A83     		strh	r2, [r3, #24]	@ movhi
 150 00a4 02E0     		b	.L13
 151              	.L12:
  91:led_blinking.c ****       }
  92:led_blinking.c ****       else
  93:led_blinking.c ****       {
  94:led_blinking.c ****         palClearPad(GPIOD, GPIOD_PIN7);
 152              		.loc 1 94 0
 153 00a6 064B     		ldr	r3, .L15+12
 154 00a8 8022     		movs	r2, #128
 155 00aa 5A83     		strh	r2, [r3, #26]	@ movhi
 156              	.L13:
  95:led_blinking.c ****       }
  96:led_blinking.c **** 
  97:led_blinking.c ****       chThdSleepMilliseconds(8);
 157              		.loc 1 97 0
 158 00ac 4720     		movs	r0, #71
 159 00ae FFF7FEFF 		bl	chThdSleep
  98:led_blinking.c **** 
  99:led_blinking.c ****     }
 160              		.loc 1 99 0
 161 00b2 AFE7     		b	.L14
 162              	.L16:
 163              		.align	2
 164              	.L15:
 165 00b4 00000000 		.word	rlist
 166 00b8 00000000 		.word	.LC0
 167 00bc 236D0100 		.word	93475
 168 00c0 000C0240 		.word	1073875968
 169              		.cfi_endproc
 170              	.LFE118:
 172 00c4 AFF30080 		.section	.bss.waPort_E0_Blinker,"aw",%nobits
 172      AFF30080 
 172      AFF30080 
 173              		.align	3
 176              	waPort_E0_Blinker:
 177 0000 00000000 		.space	440
 177      00000000 
 177      00000000 
 177      00000000 
 177      00000000 
 178              		.section	.rodata
 179              		.align	2
 180              	.LC1:
 181 0010 506F7274 		.ascii	"Port_E0_Blinker\000"
 181      5F45305F 
 181      426C696E 
 181      6B657200 
 182              		.section	.text.Port_E0_Blinker,"ax",%progbits
 183              		.align	2
 184              		.p2align 4,,15
 185              		.thumb
 186              		.thumb_func
 188              	Port_E0_Blinker:
 189              	.LFB119:
 100:led_blinking.c ****     return 0;
 101:led_blinking.c **** }
 102:led_blinking.c **** 
 103:led_blinking.c **** 
 104:led_blinking.c **** /*
 105:led_blinking.c ****  * Port E blinker thread, times are in milliseconds.
 106:led_blinking.c ****  *  Blink some of the LEDs on port E
 107:led_blinking.c ****  *
 108:led_blinking.c ****  *  This is not the clearest or the quickest way to do this, but it is by
 109:led_blinking.c ****  *      far the most clear way to do it.
 110:led_blinking.c ****  *  We get a random number and assign it to a 16-bit variable.  We then
 111:led_blinking.c ****  *    check each bit and map it to an port pin that has a transistor
 112:led_blinking.c ****  *    driven LED connected to it.
 113:led_blinking.c ****  */
 114:led_blinking.c **** static WORKING_AREA(waPort_E0_Blinker, 128);
 115:led_blinking.c **** static msg_t Port_E0_Blinker(void *arg)
 116:led_blinking.c **** {
 190              		.loc 1 116 0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 16
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194 0000 00B5     		push	{lr}
 195              		.cfi_def_cfa_offset 4
 196              		.cfi_offset 14, -4
 197 0002 85B0     		sub	sp, sp, #20
 198              		.cfi_def_cfa_offset 24
 199 0004 0190     		str	r0, [sp, #4]
 117:led_blinking.c ****     (void)arg;
 118:led_blinking.c ****     uint32_t pattern;
 119:led_blinking.c **** 
 120:led_blinking.c ****     srand( 3764 );  // seed the random number generator
 200              		.loc 1 120 0
 201 0006 40F6B460 		movw	r0, #3764
 202 000a FFF7FEFF 		bl	srand
 121:led_blinking.c **** 
 122:led_blinking.c ****     chRegSetThreadName("Port_E0_Blinker");
 203              		.loc 1 122 0
 204 000e 1E4B     		ldr	r3, .L27
 205 0010 9B69     		ldr	r3, [r3, #24]
 206 0012 1E4A     		ldr	r2, .L27+4
 207 0014 9A61     		str	r2, [r3, #24]
 208              	.L26:
 123:led_blinking.c ****     while (TRUE)
 124:led_blinking.c ****     {
 125:led_blinking.c ****       pattern = rand(); // get a new light pattern
 209              		.loc 1 125 0
 210 0016 FFF7FEFF 		bl	rand
 211 001a 0346     		mov	r3, r0
 212 001c 0393     		str	r3, [sp, #12]
 126:led_blinking.c **** 
 127:led_blinking.c ****       // check the bits and light the LEDs with set bits
 128:led_blinking.c ****       if( pattern & 0b0000000000010000 )
 213              		.loc 1 128 0
 214 001e 039B     		ldr	r3, [sp, #12]
 215 0020 03F01003 		and	r3, r3, #16
 216 0024 002B     		cmp	r3, #0
 217 0026 03D0     		beq	.L18
 129:led_blinking.c ****       {
 130:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN4);
 218              		.loc 1 130 0
 219 0028 194B     		ldr	r3, .L27+8
 220 002a 1022     		movs	r2, #16
 221 002c 1A83     		strh	r2, [r3, #24]	@ movhi
 222 002e 02E0     		b	.L19
 223              	.L18:
 131:led_blinking.c ****       }
 132:led_blinking.c ****       else
 133:led_blinking.c ****       {
 134:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN4);
 224              		.loc 1 134 0
 225 0030 174B     		ldr	r3, .L27+8
 226 0032 1022     		movs	r2, #16
 227 0034 5A83     		strh	r2, [r3, #26]	@ movhi
 228              	.L19:
 135:led_blinking.c ****       }
 136:led_blinking.c **** 
 137:led_blinking.c ****       if( pattern & 0b0000000000100000 )
 229              		.loc 1 137 0
 230 0036 039B     		ldr	r3, [sp, #12]
 231 0038 03F02003 		and	r3, r3, #32
 232 003c 002B     		cmp	r3, #0
 233 003e 03D0     		beq	.L20
 138:led_blinking.c ****       {
 139:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN5);
 234              		.loc 1 139 0
 235 0040 134B     		ldr	r3, .L27+8
 236 0042 2022     		movs	r2, #32
 237 0044 1A83     		strh	r2, [r3, #24]	@ movhi
 238 0046 02E0     		b	.L21
 239              	.L20:
 140:led_blinking.c ****       }
 141:led_blinking.c ****       else
 142:led_blinking.c ****       {
 143:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN5);
 240              		.loc 1 143 0
 241 0048 114B     		ldr	r3, .L27+8
 242 004a 2022     		movs	r2, #32
 243 004c 5A83     		strh	r2, [r3, #26]	@ movhi
 244              	.L21:
 144:led_blinking.c ****       }
 145:led_blinking.c **** 
 146:led_blinking.c ****       if( pattern & 0b0000000001000000 )
 245              		.loc 1 146 0
 246 004e 039B     		ldr	r3, [sp, #12]
 247 0050 03F04003 		and	r3, r3, #64
 248 0054 002B     		cmp	r3, #0
 249 0056 03D0     		beq	.L22
 147:led_blinking.c ****       {
 148:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN6);
 250              		.loc 1 148 0
 251 0058 0D4B     		ldr	r3, .L27+8
 252 005a 4022     		movs	r2, #64
 253 005c 1A83     		strh	r2, [r3, #24]	@ movhi
 254 005e 02E0     		b	.L23
 255              	.L22:
 149:led_blinking.c ****       }
 150:led_blinking.c ****       else
 151:led_blinking.c ****       {
 152:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN6);
 256              		.loc 1 152 0
 257 0060 0B4B     		ldr	r3, .L27+8
 258 0062 4022     		movs	r2, #64
 259 0064 5A83     		strh	r2, [r3, #26]	@ movhi
 260              	.L23:
 153:led_blinking.c ****       }
 154:led_blinking.c **** 
 155:led_blinking.c ****       if( pattern & 0b0000000010000000 )
 261              		.loc 1 155 0
 262 0066 039B     		ldr	r3, [sp, #12]
 263 0068 03F08003 		and	r3, r3, #128
 264 006c 002B     		cmp	r3, #0
 265 006e 03D0     		beq	.L24
 156:led_blinking.c ****       {
 157:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN7);
 266              		.loc 1 157 0
 267 0070 074B     		ldr	r3, .L27+8
 268 0072 8022     		movs	r2, #128
 269 0074 1A83     		strh	r2, [r3, #24]	@ movhi
 270 0076 02E0     		b	.L25
 271              	.L24:
 158:led_blinking.c ****       }
 159:led_blinking.c ****       else
 160:led_blinking.c ****       {
 161:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN7);
 272              		.loc 1 161 0
 273 0078 054B     		ldr	r3, .L27+8
 274 007a 8022     		movs	r2, #128
 275 007c 5A83     		strh	r2, [r3, #26]	@ movhi
 276              	.L25:
 162:led_blinking.c ****       }
 163:led_blinking.c **** 
 164:led_blinking.c ****       chThdSleepMilliseconds(4);
 277              		.loc 1 164 0
 278 007e 1F20     		movs	r0, #31
 279 0080 FFF7FEFF 		bl	chThdSleep
 165:led_blinking.c **** 
 166:led_blinking.c ****     }
 280              		.loc 1 166 0
 281 0084 C7E7     		b	.L26
 282              	.L28:
 283 0086 00BF     		.align	2
 284              	.L27:
 285 0088 00000000 		.word	rlist
 286 008c 10000000 		.word	.LC1
 287 0090 00100240 		.word	1073876992
 288              		.cfi_endproc
 289              	.LFE119:
 291 0094 AFF30080 		.section	.bss.waPort_E1_Blinker,"aw",%nobits
 291      AFF30080 
 291      AFF30080 
 292              		.align	3
 295              	waPort_E1_Blinker:
 296 0000 00000000 		.space	440
 296      00000000 
 296      00000000 
 296      00000000 
 296      00000000 
 297              		.section	.rodata
 298              		.align	2
 299              	.LC2:
 300 0020 506F7274 		.ascii	"Port_E1_Blinker\000"
 300      5F45315F 
 300      426C696E 
 300      6B657200 
 301              		.section	.text.Port_E1_Blinker,"ax",%progbits
 302              		.align	2
 303              		.p2align 4,,15
 304              		.thumb
 305              		.thumb_func
 307              	Port_E1_Blinker:
 308              	.LFB120:
 167:led_blinking.c ****     return 0;
 168:led_blinking.c **** }
 169:led_blinking.c **** 
 170:led_blinking.c **** 
 171:led_blinking.c **** /*
 172:led_blinking.c ****  * Port E blinker thread, times are in milliseconds.
 173:led_blinking.c ****  *  Blink some other LEDs on port E
 174:led_blinking.c ****  *
 175:led_blinking.c ****  *  This is not the clearest or the quickest way to do this, but it is by
 176:led_blinking.c ****  *      far the most clear way to do it.
 177:led_blinking.c ****  *  We get a random number and assign it to a 16-bit variable.  We then
 178:led_blinking.c ****  *    check each bit and map it to an port pin that has a transistor
 179:led_blinking.c ****  *    driven LED connected to it.
 180:led_blinking.c ****  */
 181:led_blinking.c **** static WORKING_AREA(waPort_E1_Blinker, 128);
 182:led_blinking.c **** static msg_t Port_E1_Blinker(void *arg)
 183:led_blinking.c **** {
 309              		.loc 1 183 0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 16
 312              		@ frame_needed = 0, uses_anonymous_args = 0
 313 0000 00B5     		push	{lr}
 314              		.cfi_def_cfa_offset 4
 315              		.cfi_offset 14, -4
 316 0002 85B0     		sub	sp, sp, #20
 317              		.cfi_def_cfa_offset 24
 318 0004 0190     		str	r0, [sp, #4]
 184:led_blinking.c ****     (void)arg;
 185:led_blinking.c ****     uint32_t pattern;
 186:led_blinking.c **** 
 187:led_blinking.c ****     srand( 23897 );
 319              		.loc 1 187 0
 320 0006 45F65950 		movw	r0, #23897
 321 000a FFF7FEFF 		bl	srand
 188:led_blinking.c **** 
 189:led_blinking.c ****     chRegSetThreadName("Port_E1_Blinker");
 322              		.loc 1 189 0
 323 000e 3E4B     		ldr	r3, .L47
 324 0010 9B69     		ldr	r3, [r3, #24]
 325 0012 3E4A     		ldr	r2, .L47+4
 326 0014 9A61     		str	r2, [r3, #24]
 327              	.L46:
 190:led_blinking.c **** 
 191:led_blinking.c ****     while (TRUE)
 192:led_blinking.c ****     {
 193:led_blinking.c **** 
 194:led_blinking.c ****       pattern = rand() ;
 328              		.loc 1 194 0
 329 0016 FFF7FEFF 		bl	rand
 330 001a 0346     		mov	r3, r0
 331 001c 0393     		str	r3, [sp, #12]
 195:led_blinking.c **** 
 196:led_blinking.c ****       if( pattern & 0b0000000100000000 )
 332              		.loc 1 196 0
 333 001e 039B     		ldr	r3, [sp, #12]
 334 0020 03F48073 		and	r3, r3, #256
 335 0024 002B     		cmp	r3, #0
 336 0026 04D0     		beq	.L30
 197:led_blinking.c ****       {
 198:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN8);
 337              		.loc 1 198 0
 338 0028 394B     		ldr	r3, .L47+8
 339 002a 4FF48072 		mov	r2, #256
 340 002e 1A83     		strh	r2, [r3, #24]	@ movhi
 341 0030 03E0     		b	.L31
 342              	.L30:
 199:led_blinking.c ****       }
 200:led_blinking.c ****       else
 201:led_blinking.c ****       {
 202:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN8);
 343              		.loc 1 202 0
 344 0032 374B     		ldr	r3, .L47+8
 345 0034 4FF48072 		mov	r2, #256
 346 0038 5A83     		strh	r2, [r3, #26]	@ movhi
 347              	.L31:
 203:led_blinking.c ****       }
 204:led_blinking.c **** 
 205:led_blinking.c ****       if( pattern & 0b0000001000000000 )
 348              		.loc 1 205 0
 349 003a 039B     		ldr	r3, [sp, #12]
 350 003c 03F40073 		and	r3, r3, #512
 351 0040 002B     		cmp	r3, #0
 352 0042 04D0     		beq	.L32
 206:led_blinking.c ****       {
 207:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN9);
 353              		.loc 1 207 0
 354 0044 324B     		ldr	r3, .L47+8
 355 0046 4FF40072 		mov	r2, #512
 356 004a 1A83     		strh	r2, [r3, #24]	@ movhi
 357 004c 03E0     		b	.L33
 358              	.L32:
 208:led_blinking.c ****       }
 209:led_blinking.c ****       else
 210:led_blinking.c ****       {
 211:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN9);
 359              		.loc 1 211 0
 360 004e 304B     		ldr	r3, .L47+8
 361 0050 4FF40072 		mov	r2, #512
 362 0054 5A83     		strh	r2, [r3, #26]	@ movhi
 363              	.L33:
 212:led_blinking.c ****       }
 213:led_blinking.c **** 
 214:led_blinking.c ****       if( pattern & 0b0000010000000000 )
 364              		.loc 1 214 0
 365 0056 039B     		ldr	r3, [sp, #12]
 366 0058 03F48063 		and	r3, r3, #1024
 367 005c 002B     		cmp	r3, #0
 368 005e 04D0     		beq	.L34
 215:led_blinking.c ****       {
 216:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN10);
 369              		.loc 1 216 0
 370 0060 2B4B     		ldr	r3, .L47+8
 371 0062 4FF48062 		mov	r2, #1024
 372 0066 1A83     		strh	r2, [r3, #24]	@ movhi
 373 0068 03E0     		b	.L35
 374              	.L34:
 217:led_blinking.c ****       }
 218:led_blinking.c ****       else
 219:led_blinking.c ****       {
 220:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN10);
 375              		.loc 1 220 0
 376 006a 294B     		ldr	r3, .L47+8
 377 006c 4FF48062 		mov	r2, #1024
 378 0070 5A83     		strh	r2, [r3, #26]	@ movhi
 379              	.L35:
 221:led_blinking.c ****       }
 222:led_blinking.c **** 
 223:led_blinking.c ****       if( pattern & 0b00001000000000000 )
 380              		.loc 1 223 0
 381 0072 039B     		ldr	r3, [sp, #12]
 382 0074 03F48053 		and	r3, r3, #4096
 383 0078 002B     		cmp	r3, #0
 384 007a 04D0     		beq	.L36
 224:led_blinking.c ****       {
 225:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN11);
 385              		.loc 1 225 0
 386 007c 244B     		ldr	r3, .L47+8
 387 007e 4FF40062 		mov	r2, #2048
 388 0082 1A83     		strh	r2, [r3, #24]	@ movhi
 389 0084 03E0     		b	.L37
 390              	.L36:
 226:led_blinking.c ****       }
 227:led_blinking.c ****       else
 228:led_blinking.c ****       {
 229:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN11);
 391              		.loc 1 229 0
 392 0086 224B     		ldr	r3, .L47+8
 393 0088 4FF40062 		mov	r2, #2048
 394 008c 5A83     		strh	r2, [r3, #26]	@ movhi
 395              	.L37:
 230:led_blinking.c ****       }
 231:led_blinking.c **** 
 232:led_blinking.c ****       if( pattern & 0b0001000000000000 )
 396              		.loc 1 232 0
 397 008e 039B     		ldr	r3, [sp, #12]
 398 0090 03F48053 		and	r3, r3, #4096
 399 0094 002B     		cmp	r3, #0
 400 0096 04D0     		beq	.L38
 233:led_blinking.c ****       {
 234:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN12);
 401              		.loc 1 234 0
 402 0098 1D4B     		ldr	r3, .L47+8
 403 009a 4FF48052 		mov	r2, #4096
 404 009e 1A83     		strh	r2, [r3, #24]	@ movhi
 405 00a0 03E0     		b	.L39
 406              	.L38:
 235:led_blinking.c ****       }
 236:led_blinking.c ****       else
 237:led_blinking.c ****       {
 238:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN12);
 407              		.loc 1 238 0
 408 00a2 1B4B     		ldr	r3, .L47+8
 409 00a4 4FF48052 		mov	r2, #4096
 410 00a8 5A83     		strh	r2, [r3, #26]	@ movhi
 411              	.L39:
 239:led_blinking.c ****       }
 240:led_blinking.c **** 
 241:led_blinking.c ****       if( pattern & 0b0010000000000000 )
 412              		.loc 1 241 0
 413 00aa 039B     		ldr	r3, [sp, #12]
 414 00ac 03F40053 		and	r3, r3, #8192
 415 00b0 002B     		cmp	r3, #0
 416 00b2 04D0     		beq	.L40
 242:led_blinking.c ****       {
 243:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN13);
 417              		.loc 1 243 0
 418 00b4 164B     		ldr	r3, .L47+8
 419 00b6 4FF40052 		mov	r2, #8192
 420 00ba 1A83     		strh	r2, [r3, #24]	@ movhi
 421 00bc 03E0     		b	.L41
 422              	.L40:
 244:led_blinking.c ****       }
 245:led_blinking.c ****       else
 246:led_blinking.c ****       {
 247:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN13);
 423              		.loc 1 247 0
 424 00be 144B     		ldr	r3, .L47+8
 425 00c0 4FF40052 		mov	r2, #8192
 426 00c4 5A83     		strh	r2, [r3, #26]	@ movhi
 427              	.L41:
 248:led_blinking.c ****       }
 249:led_blinking.c **** 
 250:led_blinking.c ****       if( pattern & 0b0100000000000000 )
 428              		.loc 1 250 0
 429 00c6 039B     		ldr	r3, [sp, #12]
 430 00c8 03F48043 		and	r3, r3, #16384
 431 00cc 002B     		cmp	r3, #0
 432 00ce 04D0     		beq	.L42
 251:led_blinking.c ****       {
 252:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN14);
 433              		.loc 1 252 0
 434 00d0 0F4B     		ldr	r3, .L47+8
 435 00d2 4FF48042 		mov	r2, #16384
 436 00d6 1A83     		strh	r2, [r3, #24]	@ movhi
 437 00d8 03E0     		b	.L43
 438              	.L42:
 253:led_blinking.c ****       }
 254:led_blinking.c ****       else
 255:led_blinking.c ****       {
 256:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN14);
 439              		.loc 1 256 0
 440 00da 0D4B     		ldr	r3, .L47+8
 441 00dc 4FF48042 		mov	r2, #16384
 442 00e0 5A83     		strh	r2, [r3, #26]	@ movhi
 443              	.L43:
 257:led_blinking.c ****       }
 258:led_blinking.c **** 
 259:led_blinking.c ****       if( pattern & 0b10000000000000000 )
 444              		.loc 1 259 0
 445 00e2 039B     		ldr	r3, [sp, #12]
 446 00e4 03F48033 		and	r3, r3, #65536
 447 00e8 002B     		cmp	r3, #0
 448 00ea 04D0     		beq	.L44
 260:led_blinking.c ****       {
 261:led_blinking.c ****           palSetPad(GPIOE, GPIOE_PIN15);
 449              		.loc 1 261 0
 450 00ec 084B     		ldr	r3, .L47+8
 451 00ee 4FF40042 		mov	r2, #32768
 452 00f2 1A83     		strh	r2, [r3, #24]	@ movhi
 453 00f4 03E0     		b	.L45
 454              	.L44:
 262:led_blinking.c ****       }
 263:led_blinking.c ****       else
 264:led_blinking.c ****       {
 265:led_blinking.c ****         palClearPad(GPIOE, GPIOE_PIN15);
 455              		.loc 1 265 0
 456 00f6 064B     		ldr	r3, .L47+8
 457 00f8 4FF40042 		mov	r2, #32768
 458 00fc 5A83     		strh	r2, [r3, #26]	@ movhi
 459              	.L45:
 266:led_blinking.c ****       }
 267:led_blinking.c **** 
 268:led_blinking.c ****       chThdSleepMilliseconds(3);
 460              		.loc 1 268 0
 461 00fe 1520     		movs	r0, #21
 462 0100 FFF7FEFF 		bl	chThdSleep
 269:led_blinking.c **** 
 270:led_blinking.c ****     }
 463              		.loc 1 270 0
 464 0104 87E7     		b	.L46
 465              	.L48:
 466 0106 00BF     		.align	2
 467              	.L47:
 468 0108 00000000 		.word	rlist
 469 010c 20000000 		.word	.LC2
 470 0110 00100240 		.word	1073876992
 471              		.cfi_endproc
 472              	.LFE120:
 474 0114 AFF30080 		.section	.bss.waPort_C1_Blinker,"aw",%nobits
 474      AFF30080 
 474      AFF30080 
 475              		.align	3
 478              	waPort_C1_Blinker:
 479 0000 00000000 		.space	440
 479      00000000 
 479      00000000 
 479      00000000 
 479      00000000 
 480              		.section	.rodata
 481              		.align	2
 482              	.LC3:
 483 0030 506F7274 		.ascii	"Port_C1_Blinker\000"
 483      5F43315F 
 483      426C696E 
 483      6B657200 
 484              		.section	.text.Port_C1_Blinker,"ax",%progbits
 485              		.align	2
 486              		.p2align 4,,15
 487              		.thumb
 488              		.thumb_func
 490              	Port_C1_Blinker:
 491              	.LFB121:
 271:led_blinking.c ****     return 0;
 272:led_blinking.c **** }
 273:led_blinking.c **** 
 274:led_blinking.c **** /*
 275:led_blinking.c ****  * Port C blinker thread, times are in milliseconds.
 276:led_blinking.c ****  *  Blink some LEDs on port C
 277:led_blinking.c ****  *
 278:led_blinking.c ****  *  This is not the clearest or the quickest way to do this, but it is by
 279:led_blinking.c ****  *      far the most clear way to do it.
 280:led_blinking.c ****  *  We get a random number and assign it to a 16-bit variable.  We then
 281:led_blinking.c ****  *    check each bit and map it to an port pin that has a transistor
 282:led_blinking.c ****  *    driven LED connected to it.
 283:led_blinking.c ****  */
 284:led_blinking.c **** static WORKING_AREA(waPort_C1_Blinker, 128);
 285:led_blinking.c **** static msg_t Port_C1_Blinker(void *arg)
 286:led_blinking.c **** {
 492              		.loc 1 286 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 16
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496 0000 00B5     		push	{lr}
 497              		.cfi_def_cfa_offset 4
 498              		.cfi_offset 14, -4
 499 0002 85B0     		sub	sp, sp, #20
 500              		.cfi_def_cfa_offset 24
 501 0004 0190     		str	r0, [sp, #4]
 287:led_blinking.c ****     (void)arg;
 288:led_blinking.c ****     uint32_t pattern;
 289:led_blinking.c **** 
 290:led_blinking.c ****     srand( 326 );
 502              		.loc 1 290 0
 503 0006 4FF4A370 		mov	r0, #326
 504 000a FFF7FEFF 		bl	srand
 291:led_blinking.c **** 
 292:led_blinking.c ****     chRegSetThreadName("Port_C1_Blinker");
 505              		.loc 1 292 0
 506 000e 244B     		ldr	r3, .L61
 507 0010 9B69     		ldr	r3, [r3, #24]
 508 0012 244A     		ldr	r2, .L61+4
 509 0014 9A61     		str	r2, [r3, #24]
 510              	.L60:
 293:led_blinking.c ****     while (TRUE)
 294:led_blinking.c ****     {
 295:led_blinking.c **** 
 296:led_blinking.c ****       pattern = rand() ;
 511              		.loc 1 296 0
 512 0016 FFF7FEFF 		bl	rand
 513 001a 0346     		mov	r3, r0
 514 001c 0393     		str	r3, [sp, #12]
 297:led_blinking.c **** 
 298:led_blinking.c ****       if( pattern & 0b0000000000000010 )
 515              		.loc 1 298 0
 516 001e 039B     		ldr	r3, [sp, #12]
 517 0020 03F00203 		and	r3, r3, #2
 518 0024 002B     		cmp	r3, #0
 519 0026 03D0     		beq	.L50
 299:led_blinking.c ****       {
 300:led_blinking.c ****           palSetPad(GPIOC, GPIOC_PIN1);
 520              		.loc 1 300 0
 521 0028 1F4B     		ldr	r3, .L61+8
 522 002a 0222     		movs	r2, #2
 523 002c 1A83     		strh	r2, [r3, #24]	@ movhi
 524 002e 02E0     		b	.L51
 525              	.L50:
 301:led_blinking.c ****       }
 302:led_blinking.c ****       else
 303:led_blinking.c ****       {
 304:led_blinking.c ****         palClearPad(GPIOC, GPIOC_PIN1);
 526              		.loc 1 304 0
 527 0030 1D4B     		ldr	r3, .L61+8
 528 0032 0222     		movs	r2, #2
 529 0034 5A83     		strh	r2, [r3, #26]	@ movhi
 530              	.L51:
 305:led_blinking.c ****       }
 306:led_blinking.c **** 
 307:led_blinking.c ****       if( pattern & 0b0000000000000100 )
 531              		.loc 1 307 0
 532 0036 039B     		ldr	r3, [sp, #12]
 533 0038 03F00403 		and	r3, r3, #4
 534 003c 002B     		cmp	r3, #0
 535 003e 03D0     		beq	.L52
 308:led_blinking.c ****       {
 309:led_blinking.c ****           palSetPad(GPIOC, GPIOC_PIN2);
 536              		.loc 1 309 0
 537 0040 194B     		ldr	r3, .L61+8
 538 0042 0422     		movs	r2, #4
 539 0044 1A83     		strh	r2, [r3, #24]	@ movhi
 540 0046 02E0     		b	.L53
 541              	.L52:
 310:led_blinking.c ****       }
 311:led_blinking.c ****       else
 312:led_blinking.c ****       {
 313:led_blinking.c ****         palClearPad(GPIOC, GPIOC_PIN2);
 542              		.loc 1 313 0
 543 0048 174B     		ldr	r3, .L61+8
 544 004a 0422     		movs	r2, #4
 545 004c 5A83     		strh	r2, [r3, #26]	@ movhi
 546              	.L53:
 314:led_blinking.c ****       }
 315:led_blinking.c **** 
 316:led_blinking.c ****       if( pattern & 0b0000000000010000 )
 547              		.loc 1 316 0
 548 004e 039B     		ldr	r3, [sp, #12]
 549 0050 03F01003 		and	r3, r3, #16
 550 0054 002B     		cmp	r3, #0
 551 0056 03D0     		beq	.L54
 317:led_blinking.c ****       {
 318:led_blinking.c ****           palSetPad(GPIOC, GPIOC_PIN4);
 552              		.loc 1 318 0
 553 0058 134B     		ldr	r3, .L61+8
 554 005a 1022     		movs	r2, #16
 555 005c 1A83     		strh	r2, [r3, #24]	@ movhi
 556 005e 02E0     		b	.L55
 557              	.L54:
 319:led_blinking.c ****       }
 320:led_blinking.c ****       else
 321:led_blinking.c ****       {
 322:led_blinking.c ****         palClearPad(GPIOC, GPIOC_PIN4);
 558              		.loc 1 322 0
 559 0060 114B     		ldr	r3, .L61+8
 560 0062 1022     		movs	r2, #16
 561 0064 5A83     		strh	r2, [r3, #26]	@ movhi
 562              	.L55:
 323:led_blinking.c ****       }
 324:led_blinking.c **** 
 325:led_blinking.c ****       if( pattern & 0b0000000000100000 )
 563              		.loc 1 325 0
 564 0066 039B     		ldr	r3, [sp, #12]
 565 0068 03F02003 		and	r3, r3, #32
 566 006c 002B     		cmp	r3, #0
 567 006e 03D0     		beq	.L56
 326:led_blinking.c ****       {
 327:led_blinking.c ****           palSetPad(GPIOC, GPIOC_PIN5);
 568              		.loc 1 327 0
 569 0070 0D4B     		ldr	r3, .L61+8
 570 0072 2022     		movs	r2, #32
 571 0074 1A83     		strh	r2, [r3, #24]	@ movhi
 572 0076 02E0     		b	.L57
 573              	.L56:
 328:led_blinking.c ****       }
 329:led_blinking.c ****       else
 330:led_blinking.c ****       {
 331:led_blinking.c ****         palClearPad(GPIOC, GPIOC_PIN5);
 574              		.loc 1 331 0
 575 0078 0B4B     		ldr	r3, .L61+8
 576 007a 2022     		movs	r2, #32
 577 007c 5A83     		strh	r2, [r3, #26]	@ movhi
 578              	.L57:
 332:led_blinking.c ****       }
 333:led_blinking.c **** 
 334:led_blinking.c ****       if( pattern & 0b0000000001000000 )
 579              		.loc 1 334 0
 580 007e 039B     		ldr	r3, [sp, #12]
 581 0080 03F04003 		and	r3, r3, #64
 582 0084 002B     		cmp	r3, #0
 583 0086 03D0     		beq	.L58
 335:led_blinking.c ****       {
 336:led_blinking.c ****           palSetPad(GPIOC, GPIOC_PIN6);
 584              		.loc 1 336 0
 585 0088 074B     		ldr	r3, .L61+8
 586 008a 4022     		movs	r2, #64
 587 008c 1A83     		strh	r2, [r3, #24]	@ movhi
 588 008e 02E0     		b	.L59
 589              	.L58:
 337:led_blinking.c ****       }
 338:led_blinking.c ****       else
 339:led_blinking.c ****       {
 340:led_blinking.c ****         palClearPad(GPIOC, GPIOC_PIN6);
 590              		.loc 1 340 0
 591 0090 054B     		ldr	r3, .L61+8
 592 0092 4022     		movs	r2, #64
 593 0094 5A83     		strh	r2, [r3, #26]	@ movhi
 594              	.L59:
 341:led_blinking.c ****       }
 342:led_blinking.c **** 
 343:led_blinking.c ****       chThdSleepMilliseconds(2);
 595              		.loc 1 343 0
 596 0096 0B20     		movs	r0, #11
 597 0098 FFF7FEFF 		bl	chThdSleep
 344:led_blinking.c **** 
 345:led_blinking.c ****     }
 598              		.loc 1 345 0
 599 009c BBE7     		b	.L60
 600              	.L62:
 601 009e 00BF     		.align	2
 602              	.L61:
 603 00a0 00000000 		.word	rlist
 604 00a4 30000000 		.word	.LC3
 605 00a8 00080240 		.word	1073874944
 606              		.cfi_endproc
 607              	.LFE121:
 609 00ac AFF30080 		.section	.text.start_led_blinker,"ax",%progbits
 610              		.align	2
 611              		.p2align 4,,15
 612              		.global	start_led_blinker
 613              		.thumb
 614              		.thumb_func
 616              	start_led_blinker:
 617              	.LFB122:
 346:led_blinking.c ****     return 0;
 347:led_blinking.c **** }
 348:led_blinking.c **** 
 349:led_blinking.c **** /*
 350:led_blinking.c ****  * perform configuration, then start threads for LED blinking
 351:led_blinking.c ****  */
 352:led_blinking.c **** void start_led_blinker(void)
 353:led_blinking.c **** {
 618              		.loc 1 353 0
 619              		.cfi_startproc
 620              		@ args = 0, pretend = 0, frame = 0
 621              		@ frame_needed = 0, uses_anonymous_args = 0
 622 0000 00B5     		push	{lr}
 623              		.cfi_def_cfa_offset 4
 624              		.cfi_offset 14, -4
 625 0002 83B0     		sub	sp, sp, #12
 626              		.cfi_def_cfa_offset 16
 354:led_blinking.c **** 
 355:led_blinking.c **** /*
 356:led_blinking.c ****  * configure the port pins for output, this is not the way
 357:led_blinking.c ****  * you will want to configure pins whose configuration will
 358:led_blinking.c ****  * not change during execution, but we do it here as an example.
 359:led_blinking.c ****  * You will normally configure pin modes in board.h
 360:led_blinking.c ****  */
 361:led_blinking.c **** 
 362:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN0, PAL_MODE_OUTPUT_PUSHPULL);
 627              		.loc 1 362 0
 628 0004 2E48     		ldr	r0, .L64
 629 0006 0121     		movs	r1, #1
 630 0008 0122     		movs	r2, #1
 631 000a FFF7FEFF 		bl	_pal_lld_setgroupmode
 363:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN1, PAL_MODE_OUTPUT_PUSHPULL);
 632              		.loc 1 363 0
 633 000e 2C48     		ldr	r0, .L64
 634 0010 0221     		movs	r1, #2
 635 0012 0122     		movs	r2, #1
 636 0014 FFF7FEFF 		bl	_pal_lld_setgroupmode
 364:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN2, PAL_MODE_OUTPUT_PUSHPULL);
 637              		.loc 1 364 0
 638 0018 2948     		ldr	r0, .L64
 639 001a 0421     		movs	r1, #4
 640 001c 0122     		movs	r2, #1
 641 001e FFF7FEFF 		bl	_pal_lld_setgroupmode
 365:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN3, PAL_MODE_OUTPUT_PUSHPULL);
 642              		.loc 1 365 0
 643 0022 2748     		ldr	r0, .L64
 644 0024 0821     		movs	r1, #8
 645 0026 0122     		movs	r2, #1
 646 0028 FFF7FEFF 		bl	_pal_lld_setgroupmode
 366:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN6, PAL_MODE_OUTPUT_PUSHPULL);
 647              		.loc 1 366 0
 648 002c 2448     		ldr	r0, .L64
 649 002e 4021     		movs	r1, #64
 650 0030 0122     		movs	r2, #1
 651 0032 FFF7FEFF 		bl	_pal_lld_setgroupmode
 367:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN7, PAL_MODE_OUTPUT_PUSHPULL);
 652              		.loc 1 367 0
 653 0036 2248     		ldr	r0, .L64
 654 0038 8021     		movs	r1, #128
 655 003a 0122     		movs	r2, #1
 656 003c FFF7FEFF 		bl	_pal_lld_setgroupmode
 368:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN8, PAL_MODE_OUTPUT_PUSHPULL);
 657              		.loc 1 368 0
 658 0040 1F48     		ldr	r0, .L64
 659 0042 4FF48071 		mov	r1, #256
 660 0046 0122     		movs	r2, #1
 661 0048 FFF7FEFF 		bl	_pal_lld_setgroupmode
 369:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN9, PAL_MODE_OUTPUT_PUSHPULL);
 662              		.loc 1 369 0
 663 004c 1C48     		ldr	r0, .L64
 664 004e 4FF40071 		mov	r1, #512
 665 0052 0122     		movs	r2, #1
 666 0054 FFF7FEFF 		bl	_pal_lld_setgroupmode
 370:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN10, PAL_MODE_OUTPUT_PUSHPULL);
 667              		.loc 1 370 0
 668 0058 1948     		ldr	r0, .L64
 669 005a 4FF48061 		mov	r1, #1024
 670 005e 0122     		movs	r2, #1
 671 0060 FFF7FEFF 		bl	_pal_lld_setgroupmode
 371:led_blinking.c ****   palSetPadMode(GPIOD, GPIOD_PIN11, PAL_MODE_OUTPUT_PUSHPULL);
 672              		.loc 1 371 0
 673 0064 1648     		ldr	r0, .L64
 674 0066 4FF40061 		mov	r1, #2048
 675 006a 0122     		movs	r2, #1
 676 006c FFF7FEFF 		bl	_pal_lld_setgroupmode
 372:led_blinking.c **** 
 373:led_blinking.c **** /*
 374:led_blinking.c ****  * start the threads that will blink LEDs connected to the ports
 375:led_blinking.c ****  */
 376:led_blinking.c ****   chThdCreateStatic(waPort_D0_Blinker, sizeof(waPort_D0_Blinker), NORMALPRIO+10, Port_D0_Blinker, N
 677              		.loc 1 376 0
 678 0070 0023     		movs	r3, #0
 679 0072 0093     		str	r3, [sp]
 680 0074 1348     		ldr	r0, .L64+4
 681 0076 4FF4DC71 		mov	r1, #440
 682 007a 4A22     		movs	r2, #74
 683 007c 124B     		ldr	r3, .L64+8
 684 007e FFF7FEFF 		bl	chThdCreateStatic
 377:led_blinking.c ****   chThdCreateStatic(waPort_C1_Blinker, sizeof(waPort_C1_Blinker), NORMALPRIO+10, Port_C1_Blinker, N
 685              		.loc 1 377 0
 686 0082 0023     		movs	r3, #0
 687 0084 0093     		str	r3, [sp]
 688 0086 1148     		ldr	r0, .L64+12
 689 0088 4FF4DC71 		mov	r1, #440
 690 008c 4A22     		movs	r2, #74
 691 008e 104B     		ldr	r3, .L64+16
 692 0090 FFF7FEFF 		bl	chThdCreateStatic
 378:led_blinking.c ****   chThdCreateStatic(waPort_E0_Blinker, sizeof(waPort_E0_Blinker), NORMALPRIO+10, Port_E0_Blinker, N
 693              		.loc 1 378 0
 694 0094 0023     		movs	r3, #0
 695 0096 0093     		str	r3, [sp]
 696 0098 0E48     		ldr	r0, .L64+20
 697 009a 4FF4DC71 		mov	r1, #440
 698 009e 4A22     		movs	r2, #74
 699 00a0 0D4B     		ldr	r3, .L64+24
 700 00a2 FFF7FEFF 		bl	chThdCreateStatic
 379:led_blinking.c ****   chThdCreateStatic(waPort_E1_Blinker, sizeof(waPort_E1_Blinker), NORMALPRIO+10, Port_E1_Blinker, N
 701              		.loc 1 379 0
 702 00a6 0023     		movs	r3, #0
 703 00a8 0093     		str	r3, [sp]
 704 00aa 0C48     		ldr	r0, .L64+28
 705 00ac 4FF4DC71 		mov	r1, #440
 706 00b0 4A22     		movs	r2, #74
 707 00b2 0B4B     		ldr	r3, .L64+32
 708 00b4 FFF7FEFF 		bl	chThdCreateStatic
 380:led_blinking.c **** }
 709              		.loc 1 380 0
 710 00b8 03B0     		add	sp, sp, #12
 711              		@ sp needed
 712 00ba 5DF804FB 		ldr	pc, [sp], #4
 713              	.L65:
 714 00be 00BF     		.align	2
 715              	.L64:
 716 00c0 000C0240 		.word	1073875968
 717 00c4 00000000 		.word	waPort_D0_Blinker
 718 00c8 00000000 		.word	Port_D0_Blinker
 719 00cc 00000000 		.word	waPort_C1_Blinker
 720 00d0 00000000 		.word	Port_C1_Blinker
 721 00d4 00000000 		.word	waPort_E0_Blinker
 722 00d8 00000000 		.word	Port_E0_Blinker
 723 00dc 00000000 		.word	waPort_E1_Blinker
 724 00e0 00000000 		.word	Port_E1_Blinker
 725              		.cfi_endproc
 726              	.LFE122:
 728 00e4 AFF30080 		.text
 728      AFF30080 
 728      AFF30080 
 729              	.Letext0:
 730              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 731              		.file 3 "/usr/include/newlib/stdint.h"
 732              		.file 4 "/usr/src/chibiostest/os/ports/GCC/ARMCMx/chtypes.h"
 733              		.file 5 "/usr/src/chibiostest/os/kernel/include/chlists.h"
 734              		.file 6 "/usr/src/chibiostest/os/kernel/include/chthreads.h"
 735              		.file 7 "/usr/src/chibiostest/os/ports/GCC/ARMCMx/chcore_v7m.h"
 736              		.file 8 "/usr/src/chibiostest/os/kernel/include/chschd.h"
 737              		.file 9 "/usr/src/chibiostest/os/kernel/include/chmtx.h"
 738              		.file 10 "/usr/src/chibiostest/os/hal/platforms/STM32/GPIOv2/pal_lld.h"
 739              		.file 11 "/usr/src/chibiostest/os/ports/common/ARMCMx/CMSIS/include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 led_blinking.c
     /tmp/cccObsf1.s:20     .bss.waPort_D0_Blinker:0000000000000000 $d
     /tmp/cccObsf1.s:23     .bss.waPort_D0_Blinker:0000000000000000 waPort_D0_Blinker
     /tmp/cccObsf1.s:26     .rodata:0000000000000000 $d
     /tmp/cccObsf1.s:30     .text.Port_D0_Blinker:0000000000000000 $t
     /tmp/cccObsf1.s:35     .text.Port_D0_Blinker:0000000000000000 Port_D0_Blinker
     /tmp/cccObsf1.s:165    .text.Port_D0_Blinker:00000000000000b4 $d
     /tmp/cccObsf1.s:173    .bss.waPort_E0_Blinker:0000000000000000 $d
     /tmp/cccObsf1.s:176    .bss.waPort_E0_Blinker:0000000000000000 waPort_E0_Blinker
     /tmp/cccObsf1.s:183    .text.Port_E0_Blinker:0000000000000000 $t
     /tmp/cccObsf1.s:188    .text.Port_E0_Blinker:0000000000000000 Port_E0_Blinker
     /tmp/cccObsf1.s:285    .text.Port_E0_Blinker:0000000000000088 $d
     /tmp/cccObsf1.s:292    .bss.waPort_E1_Blinker:0000000000000000 $d
     /tmp/cccObsf1.s:295    .bss.waPort_E1_Blinker:0000000000000000 waPort_E1_Blinker
     /tmp/cccObsf1.s:302    .text.Port_E1_Blinker:0000000000000000 $t
     /tmp/cccObsf1.s:307    .text.Port_E1_Blinker:0000000000000000 Port_E1_Blinker
     /tmp/cccObsf1.s:468    .text.Port_E1_Blinker:0000000000000108 $d
     /tmp/cccObsf1.s:475    .bss.waPort_C1_Blinker:0000000000000000 $d
     /tmp/cccObsf1.s:478    .bss.waPort_C1_Blinker:0000000000000000 waPort_C1_Blinker
     /tmp/cccObsf1.s:485    .text.Port_C1_Blinker:0000000000000000 $t
     /tmp/cccObsf1.s:490    .text.Port_C1_Blinker:0000000000000000 Port_C1_Blinker
     /tmp/cccObsf1.s:603    .text.Port_C1_Blinker:00000000000000a0 $d
     /tmp/cccObsf1.s:610    .text.start_led_blinker:0000000000000000 $t
     /tmp/cccObsf1.s:616    .text.start_led_blinker:0000000000000000 start_led_blinker
     /tmp/cccObsf1.s:716    .text.start_led_blinker:00000000000000c0 $d
                     .debug_frame:0000000000000010 $d
     /tmp/cccObsf1.s:172    .text.Port_D0_Blinker:00000000000000c4 $t
     /tmp/cccObsf1.s:291    .text.Port_E0_Blinker:0000000000000094 $t
     /tmp/cccObsf1.s:474    .text.Port_E1_Blinker:0000000000000114 $t
     /tmp/cccObsf1.s:609    .text.Port_C1_Blinker:00000000000000ac $t
     /tmp/cccObsf1.s:728    .text.start_led_blinker:00000000000000e4 $t

UNDEFINED SYMBOLS
srand
rand
chThdSleep
rlist
_pal_lld_setgroupmode
chThdCreateStatic
